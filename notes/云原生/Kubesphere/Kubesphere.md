---
typora-copy-images-to: imgs
---





















听课记录：

- 2023-10-12：Kubernetes 核心实战-网络模型总结






# Kubernetes基础


> 私有网络 VPC 实战



每个服务器都有两个 IP 地址：公网 ip、内网 ip

搭建服务器集群，集群之间使用内网 ip 进行通信，一是不需要走公网流量，不花钱；二是比走公网更快



VPC：专有网络

![1696753202654](imgs/1696753202654.png)











![1697115684668](imgs/1697115684668.png)



k8s 希望通过域名来区分访问的服务，当访问域名 `order.atguigu.com` 时，会访问 `service a` 下的三个 pod，当访问域名 `user.atguigu.com` 时，会访问 `service b` 下的三个pod。





k8s 的存储卷挂载，通过 nfs 进行挂载，启动一个 nfs-server，让所有 pod 需要挂载的数据都存储在 nfs-server 中。





- `ConfigMap` 可以给 pod 挂在上配置文件


- `Secrets` 可以挂载上密钥信息，例如去 dockerhub 拉取镜像，我们就可以在这里配置上用户名和密码


- `Ingress` 流量入口，可以根据域名进行负载均衡、限流等操作
- `PVM` 挂载存储声明，当挂载存储卷时，提交一个 PVM，会自动给 Pod 分一个对应大小的存储卷





# 	Kubesphere

开放服务器端口： `30000 - 32767`，因为 nodeport 暴露端口在这个范围内





## 应用部署

应用都部署在工作负载中，工作负载中又分为三个部分：部署、有状态副本集、守护进程集

- 微服务可以部署在 `工作负载(部署)` 中进行部署
- 中间件（MySQL、Redis）可以部署在 `有状态副本集` 中，这样在中间件挂掉之后，重启在另一个pod启动，数据还会存在
- 日志收集器可以部署在 `守护进程集` 中





### MySQL部署

#### 创建配置

先创建 MySQL 配置

![1697292277903](imgs/1697292277903.png)

![1697292329429](imgs/1697292329429.png)

![1697292382158](imgs/1697292382158.png)

在 mysql 的 conf.d 目录下，所有 .cnf 结尾的文件都会被 MySQL 当作配置文件



![1697292513589](imgs/1697292513589.png)

那么我们直接将 key 作为文件名，将 value 作为文件的内容





#### 创建 PVC（卷挂载）

对于 mysql 的挂载，可以参考 docker 的启动命令，来创建对应的存储卷和配置集

![1697292577492](imgs/1697292577492.png)

![1697292589305](imgs/1697292589305.png)

![1697292605849](imgs/1697292605849.png)

#### 部署 MySQL 服务

创建有状态副本集

![1697292662434](imgs/1697292662434.png)

![1697292688916](imgs/1697292688916.png)

![1697292704378](imgs/1697292704378.png)

![1697292716850](imgs/1697292716850.png)

![1697292737033](imgs/1697292737033.png)

对于 MySQL 的资源可以不进行预留，但是可以做一下限制，如果对每个 pod 都预留资源可能导致系统资源不足

![1697292765603](imgs/1697292765603.png)

![1697292846723](imgs/1697292846723.png)

![1697292883198](imgs/1697292883198.png)

![1697292914010](imgs/1697292914010.png)





![1697292924204](imgs/1697292924204.png)

![1697292969787](imgs/1697292969787.png)





部署之后，在集群内部都可以根据域名访问到这个 mysql 服务

可以通过 `mysql -uroot -h域名 -p` 来测试

![1697293388114](imgs/1697293388114.png)



这个域名是他默认给的，只能在集群内部访问，我们可以把默认的给删除掉，重新创建一个集群外也可以访问的。

`删除时，不要把有状态副本集也给删除掉` 



##### 1、创建内网可以访问的工作负载

![1697293535417](imgs/1697293535417.png)

![1697293567600](imgs/1697293567600.png)

![1697293577255](imgs/1697293577255.png)

![1697293588696](imgs/1697293588696.png)



![1697293648899](imgs/1697293648899.png)

![1697293656969](imgs/1697293656969.png)

![1697293664936](imgs/1697293664936.png)

![1697293672641](imgs/1697293672641.png)



##### 2、创建外网可以访问的工作负载



![1697293754219](imgs/1697293754219.png)

![1697293776233](imgs/1697293776233.png)

![1697293782521](imgs/1697293782521.png)

可以使用 `集群ip:port` 来进行访问 

![1697293806980](imgs/1697293806980.png)



在生产环境中，可以把外网访问的负载均衡给删除掉，只能集群内布的应用可以访问到，这样可以保证 mysql 的安全性。





### 部署Redis服务



#### docker启动redis命令

根据启动命令中的挂在数据目录来指定存储卷

部署 redis 还有一点不一样，因为redis需要特殊的启动命令`redis-server /etc/redis/redis.conf`

![1697772220010](imgs/1697772220010.png)

![1697777337349](imgs/1697777337349.png)



#### 创建redis配置

![1697777310701](imgs/1697777310701.png)



![1697777317581](imgs/1697777317581.png)





#### 创建redis

![1697777552775](imgs/1697777552775.png)

![1697777573543](imgs/1697777573543.png)

![1697777588085](imgs/1697777588085.png)

![1697777700942](imgs/1697777700942.png)

![1697777718213](imgs/1697777718213.png)



这里之前没创建过存储卷，因此创建一个新的

![1697777750470](imgs/1697777750470.png)

![1697777776621](imgs/1697777776621.png)

配置文件之前创建过了，这里直接挂载

![1697777810525](imgs/1697777810525.png)

![1697777857742](imgs/1697777857742.png)



启动redis之后，会默认创建一个redis服务，只有集群内部能够访问

![1697777941615](imgs/1697777941615.png)

我们直接删除默认的，自己新创建一个

![1697777953863](imgs/1697777953863.png)





#### 创建redis负载（集群内访问）

![1697778002136](imgs/1697778002136.png)

![1697778015999](imgs/1697778015999.png)

![1697778054381](imgs/1697778054381.png)





#### 创建redis负载（集群外访问）

![1697778090216](imgs/1697778090216.png)

![1697778109501](imgs/1697778109501.png)

![1697778119172](imgs/1697778119172.png)

![1697778126413](imgs/1697778126413.png)





**后续强制在启动容器时，都新创建一个新的存储卷，不提前创建存储卷，否则多个容器都会去连接同一个存储卷**







### 部署ES服务



#### docker运行es



![1697778631637](imgs/1697778631637.png)

对于es来说，在 `/usr/share/elasticsearch/config` 目录下有很多文件，但是我们需要挂载的只有两个文件`elasticsearch.yml、jvm.options`

![1697778775418](imgs/1697778775418.png)



那么如果我们直接挂载 config 目录的话，该目录下的所有文件都要被覆盖掉，那么我们就可以先将这两个文件的配置做出来

#### 创建配置

![1697778859492](imgs/1697778859492.png)

key是文件名，value是内容

![1697778879987](imgs/1697778879987.png)



![1697778979196](imgs/1697778979196.png)

![1697778995196](imgs/1697778995196.png)



#### 创建es

![1697779040593](imgs/1697779040593.png)

![1697779049232](imgs/1697779049232.png)

![1697779058174](imgs/1697779058174.png)

![1697779107991](imgs/1697779107991.png)



es数据挂载

![1697779153407](imgs/1697779153407.png)

配置文件挂载

![1697779171706](imgs/1697779171706.png)



之前说了，我们只需要挂载这两个配置文件，而且挂载时，不能让其他文件消失，因此这里路径我们要指定子路径`/usr/share/elasticsearch/config.elasticsearch.yml`

并且还要添加子路径为`elasticsearch.yml`

![1697779300455](imgs/1697779300455.png)

并且要选择特定的键和路径

![1697779370703](imgs/1697779370703.png)

下边挂载jvm.options文件

![1697779417175](imgs/1697779417175.png)

![1697779432217](imgs/1697779432217.png)

![1697779451269](imgs/1697779451269.png)

 

#### 创建服务

先删除默认负载服务

![1697780029646](imgs/1697780029646.png)

![1697780049312](imgs/1697780049312.png)

![1697780147958](imgs/1697780147958.png)



#### 创建服务（集群外访问）

![1697780276238](imgs/1697780276238.png)



集群外只暴露9200端口

![1697780319863](imgs/1697780319863.png)

![1697780329209](imgs/1697780329209.png)

![1697780336614](imgs/1697780336614.png)





















## 应用商店

### 应用商店部署rabbitmq

应用商店中有一些常见的应用的部署

![1697781780540](imgs/1697781780540.png)

![1697781807422](imgs/1697781807422.png)

![1697781824812](imgs/1697781824812.png)

![1697781848077](imgs/1697781848077.png)

之后在应用中可以进行查看

![1697782181340](imgs/1697782181340.png)

设置外网访问

![1697782245980](imgs/1697782245980.png)

![1697782280877](imgs/1697782280877.png)



![1697782267037](imgs/1697782267037.png)





## 应用仓库

应用商店中应用较少，如果需要部署大量应用，需要去应用仓库中

helm 是 k8s 的一个包管理工具

![1697782369984](imgs/1697782369984.png)



![1697782393621](imgs/1697782393621.png)



![1697782402300](imgs/1697782402300.png)





### 使用应用仓库

#### 添加仓库地址

![1697782455508](imgs/1697782455508.png)

需要使用有企业空间管理权限的用户，为企业空间添加应用仓库

![1697782507836](imgs/1697782507836.png)



#### 使用应用仓库部署应用

![1697783085635](imgs/1697783085635.png)

![1697783142787](imgs/1697783142787.png)

![1697783158100](imgs/1697783158100.png)

![1697783165580](imgs/1697783165580.png)

![1697783172019](imgs/1697783172019.png)



可以在工作负载中查看

![1697783214740](imgs/1697783214740.png)







## 项目部署实战-ruoyi微服务

![1697783738891](imgs/1697783738891.png)





### 项目上云注意事项：

- 中间件（数据挂载、配置）
- 制作镜像（中间件有现成的镜像，而我们的应用需要自己制作镜像）
- 网络（访问地址）
- 配置（生产配置分离，本地调试使用外网地址，上云之后使用内网地址，内网速度更快，安全性也高）



### 中间件部署

之前已经部署过mysql、redis

![1697787348304](imgs/1697787348304.png)



#### nacos部署测试

![1697788118146](imgs/1697788118146.png)

直接从服务中来创建有状态服务

![1697787712928](imgs/1697787712928.png)

![1697787727267](imgs/1697787727267.png)

![1697787755959](imgs/1697787755959.png)

![1697787774107](imgs/1697787774107.png)

![1697787780175](imgs/1697787780175.png)

![1697787810391](imgs/1697787810391.png)



**nacos的固定访问域名为：`his-nacos.his`**



那么随便进入一个nacos 的 pod 控制台，`ping his-nacos.his`，可以发现nacos集群内部每个nacos的域名都是固定的

![1697787974560](imgs/1697787974560.png)



因此在nacos集群的配置文件中，我们不填写nacos每个节点的ip，而填写域名，因为如果pod挂了，ip可能会改变，但是域名固定



#### nacos部署上云

##### 配置文件

需要挂载两个配置文件`application.properties、cluster.conf.example`

![1697788175775](imgs/1697788175775.png)



`cluster.conf` 文件内容

![1697788239414](imgs/1697788239414.png)

![1697788252334](imgs/1697788252334.png)



##### 创建nacos

![1697788272191](imgs/1697788272191.png)

![1697788291276](imgs/1697788291276.png)

![1697788298712](imgs/1697788298712.png)

![1697788310416](imgs/1697788310416.png)

![1697788326088](imgs/1697788326088.png)

![1697788333272](imgs/1697788333272.png)

![1697788345241](imgs/1697788345241.png)



**以子路径方式挂载两个配置文件**

![1697788441971](imgs/1697788441971.png)

![1697788491627](imgs/1697788491627.png)



##### 创建一个集群外访问负载均衡

![1697788553089](imgs/1697788553089.png)

![1697788572726](imgs/1697788572726.png)

![1697788592905](imgs/1697788592905.png)

![1697788602646](imgs/1697788602646.png)

![1697788615032](imgs/1697788615032.png)



**在nacos配置文件`application.properties`中，也要将mysql的ip给设置为云上的域名**

![1697788883761](imgs/1697788883761.png)



**重启nacos：先将副本数量降成0，再添加成3个副本**

![1697788927315](imgs/1697788927315.png)



在若依中，每一个微服务模块端口都是8080，并不会端口冲突，因为在k8s上，每一个微服务都是一个pod，防止启动多个微服务，需要记住多个端口，增加复杂性



在dockerfile中，不管项目中配置文件中端口是多少，在启动容器时，端口优先级是最高的，因此在 dockerfile 中指定 8080 端口

![1697790036417](imgs/1697790036417.png)



在开发环境中激活的是dev，而我们在dockerfile指定激活prod环境，如果激活dev，nacos会去寻找ruoyi-auth-dev.yaml的配置文件，如果激活prod，nacos会去寻找ruoyi-auth-prod.yaml的配置文件

![1697790225541](imgs/1697790225541.png)

因此我们要在nacos中创建生产环境的命名空间，并且将开发环境的配置文件给复制一份

![1697790288085](imgs/1697790288085.png)









